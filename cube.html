<!DOCTYPE html>
<html>
<head>
	<title>2d projected cube</title>
	<style>body{margin: 0;} canvas{position: absolute;margin: 0;z-index: 0;}</style>
</head>
<body>
	<canvas id="cartesianGrid"></canvas>
	<canvas id="cartesianCanvas"></canvas>
  <script>
    const canvas = document.getElementById('cartesianCanvas');
    const ctx = canvas.getContext('2d');
    const cubeVertices = [
        { x: -1, y: -1, z: -1 }, { x: 1, y: -1, z: -1 },
        { x: 1, y: 1, z: -1 }, { x: -1, y: 1, z: -1 },
        { x: -1, y: -1, z: 1 }, { x: 1, y: -1, z: 1 },
        { x: 1, y: 1, z: 1 }, { x: -1, y: 1, z: 1 }
    ];
    const cubeEdges = [
        [0, 1], [1, 2], [2, 3], [3, 0],
        [4, 5], [5, 6], [6, 7], [7, 4],
        [0, 4], [1, 5], [2, 6], [3, 7]
    ];
    var gridSize = window.innerWidth / 20;
    var pointDensity = 0.1;
    var pastWidth = 0;
    var pastHeight = 0;
    var currentWidth = window.innerWidth;
    var currentHeight = window.innerHeight;
    var currentOrigin = [currentWidth / 2, currentHeight / 2];
    var funToCall = [];
    var cubeSize = 1;
    var enableDrawGizmo = true;
    var initialPinchDistance = null;
    var rotationX = 0;
    var rotationY = 0;
    var isDragging = false;
    var previousMousePosition = {x: 0, y: 0};

    window.addEventListener('contextmenu', function(event) {event.preventDefault();console.log("prevented context menu !");});
    canvas.addEventListener('mousedown', (e) => {isDragging = true; previousMousePosition = {x: e.clientX, y: e.clientY};});
    window.addEventListener('mouseup', () => {isDragging = false;});
    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;
        rotationY -= deltaX * 0.005; rotationX -= deltaY * 0.005;
        previousMousePosition = {x: e.clientX, y: e.clientY};
      }
    });
    canvas.addEventListener('wheel', (e) => {e.preventDefault();
        if (e.deltaY < 0) {cubeSize += 0.1;} else {cubeSize -= 0.1;}
        cubeSize = Math.max(0.2, cubeSize);cubeSize = Math.min(5.0, cubeSize); 
    });

    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {isDragging = true;
          previousMousePosition = {x: e.touches[0].clientX, y: e.touches[0].clientY};
        } else if (e.touches.length === 2) {isDragging = false;
          initialPinchDistance = getPinchDistance(e.touches);
        } e.preventDefault();
    });
    window.addEventListener('touchend', () => {isDragging = false;initialPinchDistance = null;});
    canvas.addEventListener('touchmove', (e) => {
      if (isDragging && e.touches.length === 1) {
        const deltaX = e.touches[0].clientX - previousMousePosition.x;
        const deltaY = e.touches[0].clientY - previousMousePosition.y;
        rotationY -= deltaX * 0.005; rotationX -= deltaY * 0.005;
        previousMousePosition = {x: e.touches[0].clientX, y: e.touches[0].clientY};
        } else if (initialPinchDistance !== null && e.touches.length === 2) {
        const currentPinchDistance = getPinchDistance(e.touches);
        const deltaDistance = currentPinchDistance - initialPinchDistance;
          if (Math.abs(deltaDistance) > 5) {
            cubeSize += deltaDistance * 0.005; 
            cubeSize = Math.max(0.2, cubeSize); 
            cubeSize = Math.min(5.0, cubeSize); 
            initialPinchDistance = currentPinchDistance;
          }
        }
    });

    function getPinchDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function callerFunction() {for (let i = 0; i < funToCall.length; i++) {let {func, args} = funToCall[i];func(...args);}}

    function rotateX(point, angle) {
      const cos = Math.cos(angle);const sin = Math.sin(angle);
      const y = point.y * cos - point.z * sin;const z = point.y * sin + point.z * cos;
      point.y = y; point.z = z;
    }

    function rotateY(point, angle) {
      const cos = Math.cos(angle);const sin = Math.sin(angle);
      const x = point.x * cos + point.z * sin;const z = point.x * sin - point.z * cos;
      point.x = x;point.z = z;
    }

    function projectPoint(point) {
      const viewDistance = 3;const scale = viewDistance / (viewDistance - point.z); 
      return {x: point.x * scale, y: point.y * scale};
    }

    function drawCube(color) {
      ctx.strokeStyle = color;ctx.lineWidth = 2;
      const transformedVertices = cubeVertices.map(v => {
      let tempPoint = { x: v.x * cubeSize, y: v.y * cubeSize, z: v.z * cubeSize };
        rotateX(tempPoint, rotationX);rotateY(tempPoint, rotationY);
        return tempPoint;
      });
      cubeEdges.forEach(edge => {
        const p1 = transformedVertices[edge[0]];
        const p2 = transformedVertices[edge[1]];
        if (p1.z > -3 && p2.z > -3) { 
          const projectedP1 = projectPoint(p1);const projectedP2 = projectPoint(p2);
          const x_canvas1 = projectedP1.x * gridSize + currentOrigin[0];
          const y_canvas1 = currentOrigin[1] - projectedP1.y * gridSize;
          const x_canvas2 = projectedP2.x * gridSize + currentOrigin[0];
          const y_canvas2 = currentOrigin[1] - projectedP2.y * gridSize;
          ctx.beginPath();ctx.moveTo(x_canvas1, y_canvas1);ctx.lineTo(x_canvas2, y_canvas2);ctx.stroke();
        }
      });
    }

    function drawGizmo(originX, originY) {
      if(!enableDrawGizmo) return
      const axisLength = 1.0;const gizmoScale = cubeSize * 25;
      const axes = {
        x: { point: { x: axisLength, y: 0, z: 0 }, color: 'red' },
        y: { point: { x: 0, y: axisLength, z: 0 }, color: 'green' },
        z: { point: { x: 0, y: 0, z: axisLength }, color: 'blue' }
      };
      for (const axis in axes) {
        let tempPoint = { ...axes[axis].point };
        rotateX(tempPoint, rotationX);rotateY(tempPoint, rotationY);
        const projected = projectPoint(tempPoint);
        const x_canvas = projected.x * gizmoScale + originX;
        const y_canvas = originY - projected.y * gizmoScale;
        ctx.beginPath();ctx.strokeStyle = axes[axis].color;ctx.lineWidth = 3;
        ctx.moveTo(originX, originY); ctx.lineTo(x_canvas, y_canvas);ctx.stroke();
      }
    }

    function renderCanvas() {
      ctx.clearRect(0, 0, currentWidth, currentHeight);
      canvas.width = currentWidth;canvas.height = currentHeight;
      const canvasWidth = canvas.width;const canvasHeight = canvas.height;
      ctx.strokeStyle = 'grey';ctx.lineWidth = 1;
      const originX = currentOrigin[0];const originY = currentOrigin[1];
      for (let i = 0; i <= originX; i += gridSize) {
        ctx.beginPath();ctx.moveTo(originX + i, 0);ctx.lineTo(originX + i, canvasHeight);ctx.stroke();
        if (i > 0) {ctx.beginPath();ctx.moveTo(originX - i, 0);ctx.lineTo(originX - i, canvasHeight);ctx.stroke();}
      }
      for (let i = 0; i <= originY; i += gridSize) {
        ctx.beginPath();ctx.moveTo(0, originY + i);ctx.lineTo(canvasWidth, originY + i);ctx.stroke();
        if (i > 0) {ctx.beginPath();ctx.moveTo(0, originY - i);ctx.lineTo(canvasWidth, originY - i);ctx.stroke();}
      }
      drawCube('black');
      drawGizmo(originX, originY); 
      requestAnimationFrame(renderCanvas);
    }

    let gridCheckInterval = setInterval(() => {gridSize = window.innerWidth / 20;currentWidth = window.innerWidth; currentHeight = window.innerHeight;currentOrigin = [currentWidth / 2, currentHeight / 2];}, 100);

    requestAnimationFrame(renderCanvas);
  </script>
</body>
</html>
